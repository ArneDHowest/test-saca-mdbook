# Intro to SACA

## Lectors
- Headteacher: [arne.debou@howest.be](mailto:arne.debou@howest.be)
- Co-teacher: [shirin.kalantari@howest.be](mailto:shirin.kalantari@howest.be)
- Co-teacher: [shan.rizvi.syed@howest.be](mailto:shan.rizvi.syed@howest.be)
- Coach: [brian.baert@howest.be](mailto:brian.baert@howest.be)
- Coach: [joost.tack@howest.be](mailto:joost.tack@howest.be)
## Course

### Content
<table>
  <thead style="background-color: #f2f2f2;">
    <tr>
      <th>Week</th>
      <th>Date</th>
      <th>Content</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Week 1</td>
      <td>12/02/2025</td>
      <td>Intro Python</td>
    </tr>
    <tr style="background-color: #f2f2f2;">
      <td>Week 2.1</td>
      <td>18/02/2025</td>
      <td>Python scripting</td>
    </tr>
    <tr style="background-color: #f2f2f2;">
      <td>Week 2.2</td>
      <td>19/02/2025</td>
      <td>Python scripting</td>
    </tr>
    <tr>
      <td>Week 3.1</td>
      <td>25/02/2025</td>
      <td>Python modules</td>
    </tr>
    <tr>
      <td>Week 3.2</td>
      <td>26/02/2025</td>
      <td>Python modules OS</td>
    </tr>
    <tr style="background-color: #f2f2f2;">
      <td>Week 4.1</td>
      <td>4/03/2025</td>
      <td>Python modules Web</td>
    </tr>
    <tr style="background-color: #f2f2f2;">
      <td>Week 4.2</td>
      <td>5/03/2025</td>
      <td>Python modules Network</td>
    </tr>
    <tr>
      <td>Week 5.1</td>
      <td>11/03/2025</td>
      <td>Python modules Network</td>
    </tr>
    <tr>
      <td>Week 5.2</td>
      <td>12/03/2025</td>
      <td>Python selenium</td>
    </tr>
    <tr style="background-color: #f2f2f2;">
      <td>Week 6.1</td>
      <td>18/03/2025</td>
      <td>OOP</td>
    </tr>
    <tr style="background-color: #f2f2f2;">
      <td>Week 6.2</td>
      <td>19/03/2025</td>
      <td>OOP</td>
    </tr>
    <tr>
      <td>Week 7</td>
      <td>1/04/2025</td>
      <td>OOP</td>
    </tr>
    <tr style="background-color: #f2f2f2;">
      <td>Week 8</td>µ
      <td>21-25/04/2025</td>
      <td>Q-week</td>
    </tr>
    <tr>
      <td>Week 9.1</td>
      <td>29/04/2025</td>
      <td>Static analysis</td>
    </tr>
    <tr>
      <td>Week 9.2</td>
      <td>30/04/2025</td>
      <td>Dynamic analysis</td>
    </tr>
    <tr style="background-color: #f2f2f2;">
      <td>Week 10.1</td>
      <td>6/05/2025</td>
      <td>OCR (Open Source Built On)</td>
    </tr>
    <tr style="background-color: #f2f2f2;">
      <td>Week 10.2</td>
      <td>7/05/2025</td>
      <td>Bash script / Powershell scripting</td>
    </tr>
    <tr>
      <td>Week 11.1</td>
      <td>13/05/2025</td>
      <td>Devsecops</td>
    </tr>
    <tr>
      <td>Week 11.2</td>
      <td>14/05/2025</td>
      <td>Recap</td>
    </tr>
  </tbody>
</table>

### Project

See project assignment on Leho/GIT

## Python

### Why?
1. Ease of Learning and Use
Python is known for its simplicity and readability, making it an excellent choice for beginners and experienced programmers alike. Its syntax is clear and concise, which allows you to focus on solving problems rather than struggling with complex syntax. This ease of learning is particularly beneficial for cybersecurity specialists who need to quickly write and understand scripts.

2. Extensive Libraries and Frameworks
Python boasts a vast array of libraries and frameworks that are incredibly useful for cybersecurity tasks. Libraries such as Scapy for network packet manipulation, Requests for making HTTP requests, and PyCrypto for cryptographic operations can significantly streamline your work. These libraries save time and effort, allowing you to implement complex functionalities with minimal code.

3. Automation of Tasks
Cybersecurity often involves repetitive tasks such as scanning networks, analyzing logs, and monitoring systems. Python excels at automating these tasks, freeing up your time for more critical activities. With Python, you can write scripts to automate vulnerability scans, perform regular system checks, and even automate incident response processes.

4. Integration Capabilities
Python can easily integrate with other languages and technologies, making it a versatile tool in a cybersecurity specialist's toolkit. Whether you need to interact with web applications, databases, or network devices, Python provides the necessary libraries and modules to facilitate seamless integration. This capability is crucial for developing comprehensive security solutions that span multiple platforms and technologies.

5. Data Analysis and Visualization
In cybersecurity, analyzing large volumes of data is a common task. Python's powerful data analysis libraries, such as Pandas and NumPy, enable you to efficiently process and analyze data. Additionally, libraries like Matplotlib and Seaborn allow you to create visualizations that can help identify patterns and anomalies in your data, aiding in threat detection and analysis.

6. Scripting and Prototyping
Python is an excellent language for scripting and rapid prototyping. Its flexibility and ease of use make it ideal for writing quick scripts to test hypotheses or automate small tasks. This capability is particularly useful in cybersecurity, where you often need to quickly develop and test new tools or techniques to stay ahead of threats.

7. Community Support and Resources
Python has a large and active community of developers and cybersecurity professionals. This community provides a wealth of resources, including tutorials, forums, and open-source tools, which can be invaluable for learning and problem-solving. Whether you're facing a coding challenge or looking for advice on best practices, the Python community is there to support you.

8. Cross-Platform Compatibility
Python is a cross-platform language, meaning that scripts written in Python can run on various operating systems, including Windows, macOS, and Linux. This compatibility is essential for cybersecurity specialists who need to develop tools and scripts that work across different environments.

9. Job Market Demand
Python is one of the most in-demand programming languages in the job market, particularly in the field of cybersecurity. Many organizations seek professionals with Python skills to develop security tools, automate processes, and analyze data. By learning Python, you can enhance your employability and open up new career opportunities.

10. Open-Source Nature
Python is an open-source language, which means it is free to use and has a vast repository of open-source tools and libraries. This open-source nature fosters innovation and collaboration, allowing you to leverage existing tools and contribute to the development of new ones.

> In summary, learning Python offers numerous advantages for cybersecurity specialists. Its ease of learning, extensive libraries, automation capabilities, integration potential, data analysis tools, scripting flexibility, community support, cross-platform compatibility, job market demand, and open-source nature make it an invaluable asset in the field of cybersecurity. By mastering Python, you can enhance your efficiency, effectiveness, and career prospects in the ever-evolving world of cybersecurity.

### Environment

#### Setting Up Visual Studio Code

1. **Download and Install Visual Studio Code**:
   - Go to the Visual Studio Code download page.
   - Choose the appropriate installer for your operating system (Windows, macOS, or Linux).
   - Run the installer and follow the on-screen instructions to complete the installation.

2. **Install Python Extension for VS Code**:
   - Open Visual Studio Code.
   - Go to the Extensions view by clicking on the Extensions icon in the Activity Bar on the side of the window.
   - Search for "Python" and install the extension provided by Microsoft.

#### Installing Python, venv, and pip

1. **Download and Install Python**:
   - Visit the Python downloads page.
   - Download the latest version of Python for your operating system.
   - Run the installer and ensure you check the option to "Add Python to PATH" during installation.

2. **Create a Virtual Environment**:
   - Open a terminal or command prompt.
   - Navigate to your project directory.
   - Run the following command to create a virtual environment:
     ```bash
     python -m venv venv
     ```
   - Activate the virtual environment:
     - On Windows:
       ```bash
       .\venv\Scripts\activate
       ```
     - On macOS/Linux:
       ```bash
       source venv/bin/activate
       ```

3. **Install pip**:
   - pip is included with Python, but you can upgrade it by running:
     ```bash
     python -m pip install --upgrade pip
     ```

#### Setting Up GitLab

1. **Push to GitLab**:
   - Initialize a Git repository in your project directory:
     ```bash
     git init
     ```
   - Add your files and commit them:
     ```bash
     git add .
     git commit -m "Initial commit"
     ```
   - Add your GitLab repository as a remote and push your code:
     ```bash
     git remote add origin <your-gitlab-repo-url>
     git push -u origin master
     ```

#### Setting Up Kali Linux

1. **Download and Install Kali Linux**:
   - Go to the Kali Linux download page.
   - Download the appropriate installer for your setup (e.g., VirtualBox, VMware, or bare metal).
   - Follow the instructions to install Kali Linux on your machine or virtual environment.

2. **Generate SSH Key for GitLab**:
   - Open a terminal or command prompt.
   - Generate a new SSH key pair:
     ```bash
     ssh-keygen -t ed25519 -C "your_email@example.com"
     ```
   - Follow the prompts to save the key (default location is recommended).
   - Add the SSH key to your GitLab account:
     - Copy the public key to your clipboard:
       ```bash
       cat ~/.ssh/id_ed25519.pub
       ```
     - Go to GitLab, navigate to **Settings > SSH Keys**, and paste the key.

3. **Pull Code into Kali Machine**:
   - Open a terminal in your Kali machine.
   - Clone your GitLab repository:
     ```bash
     git clone git@gitlab.com:<your-username>/<your-repo>.git
     ```
   - Navigate to your project directory and activate the virtual environment:
     ```bash
     cd <your-repo>
     source venv/bin/activate
     ```

## Code

### Creating code
- VS Code is a special type of text editor that is called a compiler. At the top, you’ll notice a text editor. At the bottom, you will see a terminal where you can execute commands.
- In the terminal, you can execute `code hello.py` to start coding.
- In the text editor above, you can type `print("hello, world")`. This is a famous canonical program that nearly all coders write during their learning process.
- In the terminal window, you can execute commands. To run this program, you are going to need to move your cursor to the bottom of the screen, clicking in the terminal window. You can now type a second command in the terminal window. Next to the dollar sign, type `py hello.py` and press the enter key on your keyboard.
- Recall that computers really only understand zeros and ones. Therefore, when you run `py hello.py`, python will interpret the text that you created in `hello.py` and translate it into the zeros and ones that the computer can understand.
- The result of running the `py hello.py` program is `hello, world`.
- Congrats! You just created your first program.
### Functions
- Functions are verbs or actions that the computer or computer language will already know how to perform.
- In your `hello.py` program, the `print` function knows how to print to the terminal window.
- The `print` function takes arguments. In this case, `"hello, world"` are the arguments that the `print` function takes.
### Bugs
- Bugs are a natural part of coding. These are mistakes, problems for you to solve! Don’t get discouraged! This is part of the process of becoming a great programmer.
- Imagine in our `hello.py` program that accidentally typed `print("hello, world"` notice that we missed the final `)` required by the compiler. If I purposefully make this mistake, you’ll the compiler will output an error in the terminal window!
- Often, the error messages will inform you of your mistakes and provide you clues on how to fix them. However, there will be many times when the compiler is not this kind.
### Input &amp; Variables
**Asking some input** 
- We can personalize your first Python program.
- In our text editor in hello.py we can add another function. input is a function that takes a prompt as an argument. We can edit our code to say
    ```python
    input("What's your name? ")
    print("hello, world")
    ```
- This edit alone, however, will not allow your program to output what your user inputs. For that, we will need to introduce you to variables

**Variables**
- A variable is just a container for a value within your own program.
- In your program, you can introduce your own variable in your program by editing it to read
    ```python
    name = input("What's your name? ")
    print("hello, world")
    ```
- Notice that this equal = sign in the middle of name = input("What's your name? ") has a special role in programming. This equal sign literally assigns what is on the right to what is on the left. Therefore, the value returned by input("What's your name? ") is assigned to name.
- If you edit your code as follows, you will notice an error
    ```python
    name = input("What's your name? ")
    print("hello, name")
    ```
- The program will return hello, name in the terminal window regardless of what the user types.
- Further editing our code, you could type
    ```python
    name = input("What's your name? ")
    print("hello,")
    print(name)
    ```
- The result in the terminal window would be
    ```cmd
    What's your name? David
    hello
    David
    ```
- We are getting closer to the result we might intend!

**Comments**
- omments are a way for programmers to track what they are doing in their programs and even inform others about their intentions for a block of code. In short, they are notes for yourself and others who will see your code!
- You can add comments to your program to be able to see what it is that your program is doing. You might edit your code as follows:
    ```python
    # Ask the user for their name
    name = input("What's your name? ")
    print("hello,")
    print(name)
    ```
- Comments can also serve as a to-do list for you.
- Pseudocode is an important type of comment that becomes a special type of to-do list, especially when you don’t understand how to accomplish a coding task. For example, in your code, you might edit your code to say:
    ```python
    # Ask the user for their name
    name = input("What's your name? ")

    # Print hello
    print("hello,")

    # Print the name inputted
    print(name)
    ```
### Strings
- A string, known as a `str` in Python, is a sequence of text.
- Rewinding a bit in our code back to the following, there was a visual side effect of having the result appear on multiple lines:
    ```python
    # Ask the user for their name
    name = input("What's your name? ")
    print("hello,")
    print(name)
    ```
- Functions take arguments that influence their behavior. If we look at the documentation for `print` you’ll notice we can learn a lot about the arguments that the print function takes.
- Looking at this documentation, you’ll learn that the print function automatically includes a piece of code end='\n'. This \n indicates that the print function will automatically create a line break when run. The print function takes an argument called end` and the default is to create a new line.
- However, we can technically provide an argument for end ourselves such that a new line is not created!
- We can modify our code as follows:
    ```python
    # Ask the user for their name
    name = input("What's your name? ")
    print("hello,", end="")
    print(name)
    ```
    By providing end="" we are overwriting the default value of end such that it never creates a new line after this first print statement. Providing the name as “David”, the output in the terminal window will be hello, David.

- Parameters, therefore, are arguments that can be taken by a function.
- You can learn more in Python’s documentation on print.

**What to do with quotation marks?**
- Notice how adding quotation marks as part of your string is challenging.
- `print("hello,"friend"")` will not work, and the compiler will throw an error.
- Generally, there are two approaches to fixing this. First, you could simply change the quotes to single quotation marks.
- Another, more commonly used approach would be code as `print("hello, \"friend\"")`. The backslashes tell the compiler that the following character should be considered a quotation mark in the string and avoid a compiler error.

**Format strings**
- Probably the most elegant way to use strings would be as follows:
    ```python
    # Ask the user for their name
    name = input("What's your name? ")
    print(f"hello, {name}")
    ```
- Notice the `f` in `print(f"hello, {name}")`. This `f` is a special indicator for Python to treat this string a special way, different than previous approaches we have illustrated in this lecture. Expect that you will be using this style of strings quite frequently in this course.

**More on strings**

- You should never expect your user to cooperate as intended. Therefore, you will need to ensure that the input of your user is corrected or checked.
- It turns out that built into strings is the ability to remove whitespace from a string.
- By utilizing the method `strip` on `name` as `name = name.strip()`, will strip all the whitespaces on the left and right of the users input. You can modify your code to be:
    ```python
    # Ask the user for their name
    name = input("What's your name? ")

    # Remove whitespace from the str
    name = name.strip()

    # Print the output
    print(f"hello, {name}")
    ```
    Rerunning this program, regardless of how many spaces you type before or after the name, it will strip off all the whitespace.

- Using the `title` method, it would title case the user’s name:
    ```python
    # Ask the user for their name
    name = input("What's your name? ")

    # Remove whitespace from the str
    name = name.strip()

    # Capitalize the first letter of each word
    name = name.title()

    # Print the output
    print(f"hello, {name}")
    ```
- By this point, you might be very tired of typing `py` repeatedly in the terminal window. You cause use the up arrow of your keyboard to recall the most recent terminal commands you have made.
- Notice that you can modify your code to be more efficient:
    ```python
    # Ask the user for their name
    name = input("What's your name? ")

    # Remove whitespace from the str and capitalize the first letter of each word
    name = name.strip().title()

    # Print the output
    print(f"hello, {name}")
    ```
- This creates the same result as your previous code.
- We could even go further!
    ```python
    # Ask the user for their name, remove whitespace from the str and capitalize the first letter of each word
    name = input("What's your name? ").strip().title()

    # Print the output
    print(f"hello, {name}")
    ```
- You can learn more about strings in [Python’s documentation on str](https://docs.python.org/3/library/stdtypes.html#str)

### Integers
- In Python, an integer is referred to as an int.
- In the world of mathematics, we are familiar with +, -, *, /, and % operators. That last operator % or modulo operator may not be very familiar to you.
- You don’t have to use the text editor window in your compiler to run Python code. Down in your terminal, you can run `py` alone. You will be presented with `>>>` in the terminal window. You can then run live, interactive code. You could type `1+1`, and it will run that calculation. This mode will not commonly be used during this course.
- Opening up VS Code again, we can type `code calculator.py` in the terminal. This will create a new file in which we will create our own calculator.
- First, we can declare a few variables.
    ```python
    x = 1
    y = 2

    z = x + y

    print(z)
    ```
- Naturally, when we run `py calculator.py` we get the result in the terminal window of 3. We can make this more interactive using the input function.
    ```python
    x = input("What's x? ")
    y = input("What's y? ")

    z = x + y

    print(z)
    ```
- Running this program, we discover that the output is incorrect as 12. Why might this be?
- Prior, we have seen how the + sign concatenates two strings. Because your input from your keyboard on your computer comes into the compiler as text, it is treated as a string. We, therefore, need to convert this input from a string to an integer. We can do so as follows:
    ```python
    x = input("What's x? ")
    y = input("What's y? ")

    z = int(x) + int(y)

    print(z)
    ```
- The result is now correct. The use of int(x) is `called “casting”`, where a value is temporarily changed from one type of variable (in this case, a string) to another (here, an integer).
- We can further improve our program as follows:
    ```python
    x = int(input("What's x? "))
    y = int(input("What's y? "))

    print(x + y)
    ```
- This illustrates that you can run functions on functions. The inner function is run first, and then the outer one is run. First, the input function is run. Then, the int function.
- You can learn more in ]Python’s documtenation of int](https://docs.python.org/3/library/functions.html#int).
### Float
- A floating point value is a real number that has a decimal point in it, such as 0.52.
- You can change your code to support floats as follows:
    ```python
    x = float(input("What's x? "))
    y = float(input("What's y? "))

    print(x + y)
    ```
- This change allows your user to enter 1.2 and 3.4 to present a total of 4.6.
- Let’s imagine, however, that you want to round the total to the nearest integer. Looking at the Python documentation for round, you’ll see that the available arguments are `round(number[n, ndigits])`. Those square brackets indicate that something optional can be specified by the programmer. Therefore, you could do `round(n)` to round a digit to its nearest integer. Alternatively, you could code as follows:
    ```python
    # Get the user's input
    x = float(input("What's x? "))
    y = float(input("What's y? "))

    # Create a rounded result
    z = round(x + y)

    # Print the result
    print(z)
    ```
    The output will be rounded to the nearest integer.
- What if we wanted to format the output of long numbers? For example, rather than seeing 1000, you may wish to see 1,000. You could modify your code as follows:
    ```python
    # Get the user's input
    x = float(input("What's x? "))
    y = float(input("What's y? "))

    # Create a rounded result
    z = round(x + y)

    # Print the formatted result
    print(f"{z:,}")
    ```
    Though quite cryptic, that `print(f"{z:,}")` creates a scenario where the outputted z will include commas where the result could look like 1,000 or 2,500.

- How can we round floating point values? First, modify your code as follows:
    ```python
    # Get the user's input
    x = float(input("What's x? "))
    y = float(input("What's y? "))

    # Calculate the result
    z = x / y

    # Print the result
    print(z)
    ```
- When inputting 2 as x and 3 as y, the result z is 0.6666666666, seemingly going on to infinite as we might expect.

- Let’s imagine that we want to round this down. We could modify our code as follows:
    ```python
    # Get the user's input
    x = float(input("What's x? "))
    y = float(input("What's y? "))

    # Calculate the result and round
    z = round(x / y, 2)

    # Print the result
    print(z)
    ```
- As we might expect, this will round the result to the nearest two decimal points.

- We could also use fstring to format the output as follows:
    ```python
    # Get the user's input
    x = float(input("What's x? "))
    y = float(input("What's y? "))

    # Calculate the result
    z = x / y

    # Print the result
    print(f"{z:.2f}")
    ```
- This cryptic fstring code displays the same as our prior rounding strategy.

- You can learn more in [Python’s documentation of float](https://docs.python.org/3/library/functions.html#float).

### Def &amp; return values

- Wouldn’t it be nice to create our own functions?
- Let’s bring back our final code of hello.py by typing code hello.py into the terminal window. Your starting code should look as follows:
    ```python
    # Ask the user for their name, remove whitespace from the str and capitalize the first letter of each word
    name = input("What's your name? ").strip().title()

    # Print the output
    print(f"hello, {name}")
    ```
- We can better our code to create our own special function that says “hello” for us!

- Erasing all our code in our text editor, let’s start from scratch:
    ```python
    name = input("What's your name? ")
    hello()
    print(name)
    ```
- Attempting to run this code, your compiler will throw an error. After all, there is no defined function for hello.
- We can create our own function called hello as follows:
    ```python
    def hello():
        print("hello")


    name = input("What's your name? ")
    hello()
    print(name)
    ```
    Notice that everything under def hello() is indented. Python is an indented language. It uses indentation to understand what is part of the above function. Therefore, everything in the hello function must be indented. When something is not indented, it treats it as if it is not inside the hello function. Running python hello.py in the terminal window, you’ll see that your output is not exactly as you may want.

- We can further improve our code:
    ```python
    # Create our own function
    def hello(to):
        print("hello,", to)


    # Output using our own function
    name = input("What's your name? ")
    hello(name)
    ```
    Here, in the first lines, you are creating your hello function. This time, however, you are telling the compiler that this function takes a single parameter: a variable called to. Therefore, when you call hello(name) the computer passes name into the hello function as to. This is how we pass values into functions. Very useful! Running python hello.py in the terminal window, you’ll see that the output is much closer to our ideal presented earlier in this lecture.

- We can change our code to add a default value to hello:
    ```python
    # Create our own function
    def hello(to="world"):
        print("hello,", to)


    # Output using our own function
    name = input("What's your name? ")
    hello(name)

    # Output without passing the expected arguments
    hello()
    ```
- Test out your code yourself. Notice how the first hello will behave as you might expect, and the second hello, which is not passed a value, will, by default, output hello, world.

- We don’t have to have our function at the start of our program. We can move it down, but we need to tell the compiler that we have a main function and a separate hello function.
    ```python
    def main():

        # Output using our own function
        name = input("What's your name? ")
        hello(name)

        # Output without passing the expected arguments
        hello()


    # Create our own function
    def hello(to="world"):
        print("hello,", to)
    ```
- This alone, however, will create an error of sorts. If we run python hello.py, nothing happens! The reason for this is that nothing in this code is actually calling the main function and bringing our program to life.

- The following very small modification will call the main function and restore our program to working order:
    ```python
    def main():

        # Output using our own function
        name = input("What's your name? ")
        hello(name)

        # Output without passing the expected arguments
        hello()


    # Create our own function
    def hello(to="world"):
        print("hello,", to)


    main()
    ```
- You can imagine many scenarios where you don’t just want a function to perform an action but also to return a value back to the main function. For example, rather than simply printing the calculation of x + y, you may want a function to return the value of this calculation back to another part of your program. This “passing back” of a value we call a return value.
- Returning to our calculator.py code by typing code calculator.py. Erase all code there. Rework the code as follows:
    ```python
    def main():
        x = int(input("What's x? "))
        print("x squared is", square(x))


    def square(n):
        return n * n


    main()
    ```
    Effectively, x is passed to square. Then, the calculation of x * x is returned back to the main function.
